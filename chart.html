<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>BTCUSDT Chart</title>
  <style>
    body { margin: 0; background: white; }
    canvas { display: block; margin: auto; background: white; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="chart" width="648" height="480"></canvas>
  <script>
    async function getData() {
      const end = Math.floor(Date.now() / 1000);
      const start = end - 12 * 60 * 60; // posledních 12 hodin
      const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=15m&startTime=${start * 1000}&endTime=${end * 1000}`;
      const response = await fetch(url);
      const raw = await response.json();
      return raw.map(d => ({
        t: d[0],
        o: +d[1],
        h: +d[2],
        l: +d[3],
        c: +d[4]
      }));
    }

    function draw(candles) {
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Přizpůsobené paddingy pro nové rozložení textu
      const paddingLeft = 20; 
      const paddingRight = 70; 
      const paddingTop = 45; 
      const paddingBottom = 60; 

      const w = canvas.width - paddingLeft - paddingRight;
      const h = canvas.height - paddingTop - paddingBottom;
      const n = candles.length;

      const times = candles.map(c => c.t);
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);
      const prices = candles.flatMap(c => [c.l, c.h]);
      const minPrice = Math.floor(Math.min(...prices) / 500) * 500;
      const adjustedMinPrice = Math.max(minPrice, Math.min(...prices)); 
      const maxPrice = Math.ceil(Math.max(...prices) / 500) * 500;

      const scaleX = w / (maxTime - minTime);
      const scaleY = h / (maxPrice - adjustedMinPrice); 

      ctx.strokeStyle = 'black';
      ctx.fillStyle = 'black';
      // ctx.textAlign a ctx.textBaseline budou nastaveny specificky pro každou část

      // Y osa (plná vertikální čára) na PRAVÉ STRANĚ
      const axisY_XPosition = paddingLeft + w; 
      ctx.beginPath();
      ctx.moveTo(axisY_XPosition, paddingTop);
      ctx.lineTo(axisY_XPosition, paddingTop + h);
      ctx.stroke();

      // Y osa (popisky cen) na PRAVÉ STRANĚ od osy
      ctx.font = '12px Roboto, sans-serif'; 
      ctx.textAlign = 'left'; 
      ctx.textBaseline = 'middle'; 

      for (let p = minPrice; p <= maxPrice; p += 500) { 
        const y = paddingTop + h - (p - adjustedMinPrice) * scaleY; 
        
        if (p === minPrice) { 
          ctx.textBaseline = 'bottom'; 
          ctx.fillText(p.toLocaleString(), axisY_XPosition + 5, y + 2); 
          ctx.textBaseline = 'middle'; 
        } else {
          ctx.fillText(p.toLocaleString(), axisY_XPosition + 5, y); 
        }
      }
      ctx.setLineDash([]); 

      // X osa (plná vodorovná čára dole)
      ctx.beginPath();
      ctx.moveTo(paddingLeft, paddingTop + h);
      ctx.lineTo(paddingLeft + w, paddingTop + h);
      ctx.stroke();

      // Candlesticky
      const barWidth = Math.max(2, w / n * 0.6);
      candles.forEach(c => {
        const x = paddingLeft + (c.t - minTime) * scaleX;
        const yOpen = paddingTop + h - (c.o - adjustedMinPrice) * scaleY; 
        const yClose = paddingTop + h - (c.c - adjustedMinPrice) * scaleY; 
        const yHigh = paddingTop + h - (c.h - adjustedMinPrice) * scaleY; 
        const yLow = paddingTop + h - (c.l - adjustedMinPrice) * scaleY;   

        if (x - barWidth / 2 < paddingLeft || x + barWidth / 2 > paddingLeft + w) return; 

        ctx.strokeStyle = 'black'; 
        ctx.beginPath();
        ctx.moveTo(x, yHigh);
        ctx.lineTo(x, yLow);
        ctx.stroke();

        const xBar = x - barWidth / 2;
        if (c.c >= c.o) {
          ctx.fillStyle = 'black'; 
          ctx.fillRect(xBar, yClose, barWidth, yOpen - yClose);
        } else {
          ctx.fillStyle = 'white'; 
          ctx.fillRect(xBar, yClose, barWidth, yOpen - yClose);
          ctx.strokeRect(xBar, yClose, barWidth, yOpen - yClose); 
        }
      });

      // X osa (časy)
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillStyle = 'black';
      ctx.font = '12px Roboto, sans-serif'; 

      const firstHourTimestamp = Math.ceil(minTime / (1000 * 60 * 60)) * (1000 * 60 * 60);

      for (let t = firstHourTimestamp; t <= maxTime; t += (1000 * 60 * 60)) {
        const x = paddingLeft + (t - minTime) * scaleX;

        if (x < paddingLeft || x > paddingLeft + w) continue;

        const dateAtTime = new Date(t);
        const hour = dateAtTime.getHours(); 
        const label = `${('0' + hour).slice(-2)}:00`;

        ctx.fillText(label, x, paddingTop + h + 5);
      }

      // --- Nová vodorovná čárkovaná linka na aktuální ceně ---
      const currentPrice = candles[candles.length - 1].c; 
      const yCurrentPrice = paddingTop + h - (currentPrice - adjustedMinPrice) * scaleY;

      ctx.setLineDash([5, 5]); 
      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(paddingLeft, yCurrentPrice);
      ctx.lineTo(paddingLeft + w, yCurrentPrice);
      ctx.stroke();
      ctx.setLineDash([]); 

      // --- Zobrazení aktuální ceny vlevo u čárkované linky (UPRAVENO) ---
      const currentPriceToDisplay = Math.round(currentPrice); // Zaokrouhlení na celé číslo
      
      ctx.fillStyle = 'black';
      ctx.font = '12px Roboto, sans-serif'; // Normální (netučné) písmo
      ctx.textAlign = 'left'; 
      ctx.textBaseline = 'bottom'; // Nastavíme na 'bottom', aby se text vykreslil NAD Y-souřadnicí

      // X pozice je stále 5px od levého okraje, ale Y pozice je o 5px výše (nad linkou)
      ctx.fillText(currentPriceToDisplay.toLocaleString(), 5, yCurrentPrice - 5); 

      // --- Horní řádek textu: Ticker, Nákupní cena, Aktuální cena, Profit ---
      const averageBuyPrice = 78000;
      // const currentPrice = candles[candles.length - 1].c; // Už definováno výše

      let profitPercentage = 0;
      if (averageBuyPrice > 0) {
        profitPercentage = ((currentPrice - averageBuyPrice) / averageBuyPrice) * 100;
      }

      const currentPriceRounded = Math.round(currentPrice);

      const tickerText = 'BTCUSDT';
      const avgBuyPriceText = `Nákupní cena: ${averageBuyPrice.toLocaleString()} USDT`;
      const currentPriceText = `Aktuální cena: ${currentPriceRounded.toLocaleString()} USDT`;
      const profitFormattedText = `${profitPercentage.toFixed(2)}%`;

      const textSegments = [
          tickerText,
          avgBuyPriceText,
          currentPriceText,
          `Profit: ${profitFormattedText}`
      ];

      const spacingBetweenSegments = 20;

      let totalWidth = 0;
      ctx.font = 'bold 12px Roboto, sans-serif';

      const segmentWidths = textSegments.map(segment => {
          const width = ctx.measureText(segment).width;
          totalWidth += width;
          return width;
      });

      totalWidth += (textSegments.length - 1) * spacingBetweenSegments;

      const startX = (canvas.width / 2) - (totalWidth / 2);
      const topRowY = 20;

      let currentX = startX;

      ctx.textAlign = 'left';
      ctx.fillStyle = 'black';

      ctx.fillText(tickerText, currentX, topRowY);
      currentX += segmentWidths[0] + spacingBetweenSegments;

      ctx.fillText(avgBuyPriceText, currentX, topRowY);
      currentX += segmentWidths[1] + spacingBetweenSegments;

      ctx.fillText(currentPriceText, currentX, topRowY);
      currentX += segmentWidths[2] + spacingBetweenSegments;

      if (profitPercentage >= 0) {
          ctx.fillStyle = 'black';
      } else {
          ctx.fillStyle = 'red';
      }
      ctx.fillText(`Profit: ${profitFormattedText}`, currentX, topRowY);

      // --- Spodní řádek textu: "Poslední aktualizace:", Datum, Čas a Timeframe ---
      const lastCandleTime = new Date(candles[candles.length - 1].t);

      const day = ('0' + lastCandleTime.getDate()).slice(-2);
      const month = ('0' + (lastCandleTime.getMonth() + 1)).slice(-2);
      const year = lastCandleTime.getFullYear();
      const formattedDate = `${day}.${month}.${year}`;

      const cestHours = lastCandleTime.getHours();
      const cestMins = ('0' + lastCandleTime.getMinutes()).slice(-2);

      const utcHours = lastCandleTime.getUTCHours();
      const nyHours = (utcHours - 4 + 24) % 24;
      const nyMins = ('0' + lastCandleTime.getUTCMinutes()).slice(-2);

      const updateText = `Poslední aktualizace:`;
      const timeAndDateText = `${formattedDate} ${cestHours}:${cestMins} CEST | ${nyHours}:${nyMins} NY`;
      const timeframeText = `Time Frame: 15 minut`;

      const bottomTextSegments = [
          updateText,
          timeAndDateText,
          timeframeText
      ];

      let totalBottomWidth = 0;
      ctx.font = '12px Roboto, sans-serif';

      const bottomSegmentWidths = bottomTextSegments.map(segment => {
          const width = ctx.measureText(segment).width;
          totalBottomWidth += width;
          return width;
      });

      const spacingBottomSegments = 20;
      totalBottomWidth += (bottomTextSegments.length - 1) * spacingBottomSegments;

      const bottomStartX = (canvas.width / 2) - (totalBottomWidth / 2);
      const bottomTextY = canvas.height - 20;

      let currentBottomX = bottomStartX;

      ctx.textAlign = 'left';
      ctx.fillStyle = 'black';

      ctx.fillText(updateText, currentBottomX, bottomTextY);
      currentBottomX += bottomSegmentWidths[0] + spacingBottomSegments;

      ctx.fillText(timeAndDateText, currentBottomX, bottomTextY);
      currentBottomX += bottomSegmentWidths[1] + spacingBottomSegments;

      ctx.fillText(timeframeText, currentBottomX, bottomTextY);
    }

    getData().then(draw);
  </script>
</body>
</html>